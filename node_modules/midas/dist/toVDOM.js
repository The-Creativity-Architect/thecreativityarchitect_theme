'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _htmlTags = require('html-tags');

var _htmlTags2 = _interopRequireDefault(_htmlTags);

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _hastscript = require('hastscript');

var _hastscript2 = _interopRequireDefault(_hastscript);

var _vendors = require('vendors');

var _vendors2 = _interopRequireDefault(_vendors);

var _hspan = require('./hspan');

var _hspan2 = _interopRequireDefault(_hspan);

var _mediaTypes = require('./mediaTypes');

var _mediaTypes2 = _interopRequireDefault(_mediaTypes);

var _raws = require('./raws');

var _types = require('./types');

var t = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function walkDeclValues(values, container) {
    values.nodes.forEach(function (node) {
        var type = node.type,
            value = node.value;

        if (type === t.string) {
            var quote = node.quote;

            container.push((0, _hspan2.default)(t.string, '' + quote + value + quote));
        }
        if (type === t.word) {
            var number = (0, _postcssValueParser.unit)(value);
            if (number) {
                container.push((0, _hspan2.default)(t.number, value));
                return;
            }
            if (!node.value.indexOf('#')) {
                container.push((0, _hspan2.default)(t.hexColor, ['#', (0, _hspan2.default)(t.hexValue, value.slice(1))]));
                return;
            }
            container.push((0, _hspan2.default)(t.word, value));
            return;
        }
        if (type === t.func) {
            var funcValues = [(0, _hspan2.default)(t.funcName, value), (0, _hspan2.default)(t.parenthesis, '(' + node.before)];

            walkDeclValues(node, funcValues);

            funcValues.push((0, _hspan2.default)(t.parenthesis, node.after + ')'));

            container.push((0, _hspan2.default)(t.func, funcValues));
        }
        if (type === 'div') {
            container.push('' + node.before + value + node.after);
        }
        if (type === 'space') {
            container.push(value);
        }
    });
}

function selectorValues(reference) {
    return function (selectors) {
        function loop(parent, container) {
            function push(node, ref) {
                if (node.spaces.before) {
                    container.push(node.spaces.before);
                }
                if (Array.isArray(ref)) {
                    container.push.apply(container, ref);
                } else {
                    container.push(ref);
                }
                if (node.spaces.after) {
                    container.push(node.spaces.after);
                }
            }

            parent.nodes.forEach(function (node) {
                var type = node.type,
                    value = node.value;

                if (type === t.selector) {
                    loop(node, container);
                    if (node.next()) {
                        container.push(',');
                    }
                }
                if (type === t.attribute) {
                    var parts = [(0, _hspan2.default)(t.attributeBrace, '['), node.ns, (0, _hspan2.default)(t.attributeName, node.attribute)];

                    if (node.operator) {
                        parts.push((0, _hspan2.default)(t.attributeOperator, node.operator));
                    }

                    if (value) {
                        parts.push((0, _hspan2.default)(t.attributeValue, value));
                    }

                    if (node.raws.insensitive) {
                        parts.push((0, _hspan2.default)(t.attributeInsensitive, node.raws.insensitive));
                    }

                    push(node, (0, _hspan2.default)(t.attribute, [].concat(parts, [(0, _hspan2.default)(t.attributeBrace, ']')])));
                }
                if (type === t.pseudo) {
                    var name = (0, _hspan2.default)(t.pseudo, value);
                    if (node.length) {
                        var reference2 = [];
                        loop(node, reference2);

                        push(node, [name, (0, _hspan2.default)(t.parenthesis, '(')].concat(reference2, [(0, _hspan2.default)(t.parenthesis, ')')]));
                    } else {
                        push(node, name);
                    }
                }
                if (type === t.tag) {
                    if (~_htmlTags2.default.indexOf(value)) {
                        push(node, [node.ns, (0, _hspan2.default)(t.tag, value)]);
                    } else {
                        push(node, [node.ns, value]);
                    }
                }
                if (type === t.className) {
                    push(node, [node.ns, (0, _hspan2.default)(t.className, '.' + value)]);
                }
                if (type === t.id) {
                    push(node, [node.ns, (0, _hspan2.default)(t.id, '#' + value)]);
                }
                if (type === t.combinator || type === t.universal) {
                    push(node, (0, _hspan2.default)(type, value));
                }
            });
        }

        loop(selectors, reference);
    };
}

/**
 * Convert a PostCSS AST into a virtual DOM tree, with hastscript.
 *
 * @constructor
 * @private
 * @param {Object} [opts] Options object.
 * @param {boolean} [opts.wrap=true] Wrap the output with `<pre class="midas"></pre>`.
 * By default, the CSS will also be wrapped with `<code></code>`.
 */

var ToVDOM = function () {
    function ToVDOM(opts) {
        _classCallCheck(this, ToVDOM);

        var _wrap$opts = _extends({
            wrap: true
        }, opts),
            wrap = _wrap$opts.wrap;

        this.wrap = wrap;
    }

    ToVDOM.prototype.getContent = function getContent(node) {
        this.ast = [];
        this.handle(node);
        var code = (0, _hastscript2.default)('code', this.ast);

        if (this.wrap) {
            return (0, _hastscript2.default)('pre.midas', code);
        }

        return code;
    };

    /**
     * Given a PostCSS node, call the method that corresponds to its
     * defined type. The "self" variable here is for Flow's benefit.
     *
     * @param node PostCSS node.
     * @param semicolon Should the method add a semicolon to the output?
     */

    ToVDOM.prototype.handle = function handle(node, semicolon) {
        var self = this;
        self[node.type](node, semicolon);
    };

    ToVDOM.prototype.atrule = function atrule(node, semicolon) {
        var ast = this.ast;

        var name = [(0, _hspan2.default)(t.atRuleName, '@' + node.name)];

        var container = [];

        if (node.params) {
            var parsed = (0, _postcssValueParser2.default)((0, _raws.rawValue)(node, 'params'));
            parsed.nodes.forEach(function (child) {
                var value = child.value,
                    type = child.type;

                if (type === t.string) {
                    var quote = child.quote;

                    container.push((0, _hspan2.default)(t.string, '' + quote + value + quote));
                    return;
                }
                if (~_mediaTypes2.default.indexOf(value) && node.name === 'media') {
                    container.push((0, _hspan2.default)(t.atRuleKeyword, value));
                    return;
                }
                if (type === t.func) {
                    var _ret = function () {
                        var funcValues = [];

                        if (value) {
                            funcValues.push((0, _hspan2.default)(t.funcName, value));
                        }

                        funcValues.push((0, _hspan2.default)(t.parenthesis, '('), child.before);

                        child.nodes.forEach(function (n, i) {
                            if (n.type === 'div' && n.value === ':') {
                                funcValues.push((0, _hspan2.default)(t.colon, '' + n.before + n.value + n.after));
                                return;
                            }
                            if (n.type === 'div') {
                                funcValues.push('' + n.before + n.value + n.after);
                                return;
                            }
                            if (n.type === t.word) {
                                var number = (0, _postcssValueParser.unit)(n.value);
                                if (number) {
                                    funcValues.push((0, _hspan2.default)(t.number, n.value));
                                    return;
                                }
                                if (child.nodes[i + 1] && child.nodes[i + 1].value === ':') {
                                    funcValues.push((0, _hspan2.default)(t.property, n.value));
                                    return;
                                }
                            }
                            if (n.type === t.string) {
                                var _quote = n.quote;

                                funcValues.push((0, _hspan2.default)(t.string, '' + _quote + n.value + _quote));
                                return;
                            }
                            funcValues.push(n.value);
                        });
                        funcValues.push(child.after, (0, _hspan2.default)(t.parenthesis, ')'));

                        container.push((0, _hspan2.default)(t.func, funcValues));
                        return {
                            v: void 0
                        };
                    }();

                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                }
                if (type === 'div') {
                    container.push('' + child.before + value + child.after);
                    return;
                }
                container.push(value);
            });
        }

        if (typeof node.raws.afterName !== 'undefined') {
            name.push(node.raws.afterName);
        }

        if (node.nodes) {
            this.block(node, (0, _hspan2.default)(t.atRule, [].concat(name, container)));
        } else {
            var end = node.raws.between || '';
            var atrule = [].concat(name, container, [end]);
            if (semicolon) {
                atrule.push((0, _hspan2.default)(t.semicolon, ';'));
            }
            ast.push((0, _hspan2.default)(t.atRule, atrule));
        }
    };

    ToVDOM.prototype.body = function body(node) {
        var last = node.nodes.length - 1;
        while (last > 0) {
            if (node.nodes[last].type !== t.comment) {
                break;
            }
            last--;
        }

        var semicolon = (0, _raws.raw)(node, 'semicolon');
        for (var i = 0; i < node.nodes.length; i++) {
            var child = node.nodes[i];
            var before = (0, _raws.raw)(child, 'before');
            if (before) {
                this.ast.push(before);
            }
            this.handle(child, last !== i || semicolon);
        }
    };

    ToVDOM.prototype.block = function block(node, start) {
        var ast = this.ast;

        ast.push(start, (0, _raws.raw)(node, 'between', 'beforeOpen'), (0, _hspan2.default)(t.brace, '{'));

        var after = (0, _raws.raw)(node, 'after', 'emptyBody');
        if (node.nodes && node.nodes.length) {
            this.body(node);
            after = (0, _raws.raw)(node, 'after');
        }

        ast.push(after, (0, _hspan2.default)(t.brace, '}'));
    };

    ToVDOM.prototype.comment = function comment(node) {
        var left = (0, _raws.raw)(node, 'left', 'commentLeft');
        var right = (0, _raws.raw)(node, 'right', 'commentRight');
        this.ast.push((0, _hspan2.default)(t.comment, '/*' + left + node.text + right + '*/'));
    };

    ToVDOM.prototype.decl = function decl(node, semicolon) {
        var ast = this.ast;


        var hasVendor = _vendors2.default.some(function (vendor) {
            var prefix = '-' + vendor + '-';
            if (!node.prop.indexOf(prefix)) {
                ast.push((0, _hspan2.default)(t.property, [(0, _hspan2.default)(t.vendorPrefix, prefix), node.prop.replace(prefix, '')]));
                return true;
            }
        });

        if (!hasVendor) {
            ast.push((0, _hspan2.default)(t.property, node.prop));
        }

        ast.push((0, _hspan2.default)(t.colon, (0, _raws.raw)(node, 'between', t.colon)));

        var parsed = (0, _postcssValueParser2.default)((0, _raws.rawValue)(node, t.value));
        var declValues = [];
        walkDeclValues(parsed, declValues);
        ast.push((0, _hspan2.default)(t.value, declValues));

        if (node.important) {
            ast.push((0, _hspan2.default)(t.important, node.raws.important || ' !' + t.important));
        }

        if (semicolon) {
            ast.push((0, _hspan2.default)(t.semicolon, ';'));
        }
    };

    ToVDOM.prototype.rule = function rule(node) {
        var selectorVals = [];
        (0, _postcssSelectorParser2.default)(selectorValues(selectorVals)).process((0, _raws.rawValue)(node, t.selector)).result;
        this.block(node, (0, _hspan2.default)(t.selector, selectorVals));
    };

    ToVDOM.prototype.root = function root(node) {
        this.body(node);
        if (node.raws.after) {
            this.ast.push(node.raws.after);
        }
    };

    return ToVDOM;
}();

exports.default = ToVDOM;
module.exports = exports['default'];